# exec, 调用并执行指令

exec命令用于调用并执行指令的命令, 通常用在shell脚本程序中, 可以调用其他的命令, 如果在当前终端使用命令, 则当指定的命令执行完毕后会立即退出终端

语法:
`exec (选项) (参数)`

选项:
`-c, 在空环境中执行指定的命令`

参数:
要执行的指令和相应的参数

系统调用exec是以新的进程去代替原来的进程, 但进程的PID保持不变. 因此, 可以这样认为, exec系统调用并没有创建新的进程, 只是替换了原来进程上下文的内容, 原进程的代码段, 堆栈段被新的进程所代替

执行exec系统调用, 一般是这样, 用fork()函数新建一个进程, 然后让进程去执行exec调用. 在fork()建立新进程之后, 父进程与子进程共享代码段, 但数据空间是分开的, 父进程会把自己数据空间的内容copy到子进程中去, 还有上下文也会copy到子进程, 为了提高效率, 采用一种写时copy的策略, 即创建子进程的时候, 并不copy父进程的地址空间, 父子进程拥有共同的地址空间, 只有当子进程需要写入数据时(如向缓冲区写入数据), 这时候会复制地址空间, 复制缓冲区到子进程中去, 从而父子进程拥有独立的地址空间. 而对于fork()之后执行exec后, 这种策略能够很好地提高效率, 如果一开始就copy, 那么exec之后, 子进程的数据会被放弃, 被新的进程所代替

exec与system的区别:
+ exec是直接用新的进程去代替原来的程序运行, 运行完毕后不回到原先的程序中去
+ system是调用shell执行你的命令, system=fork+exec+waitpid, 执行完毕之后, 回到原先的程序中去
+ 如果你用exec调用, 首先应该fork一个新的进程, 然后exec, 而system不需要你fork新进程, 已经封装好了

exec I/O重定向:
```
exec ls    //在shell中执行ls, ls结束后不返回原来的shell
exec > text     //将当前shell的标准输出都打开到text文件中
exec > /dev/tty     //恢复重定向到stdout
exec 3>/home/test  //增加一个设备, fd3相当于一个管道, 
                   //重定向到fd3中的文件会被写在test中
exec 3>&-       //关闭这个重定向
```
