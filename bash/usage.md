
## 不同执行方式对文件权限的要求
+ bash xx.sh
1. 对脚本有r权限
2. 对脚本所在目录有rx权限
+ xx.sh
1. 对脚本有rx权限
2. 对脚本所在目录有rx权限

## 选项
bash -x xx.sh  执行该脚本并显示脚本执行的过程
bash -n xx.sh  不执行脚本只检查语法错误

## eval
eval首先会扫描命令行进行所有的置换, 然后再执行该命令
> pipe="|"
> eval ls $pipe wc -l

## 输入输出

### stdin, 读取标准输入
read a b c
less <&0
cat -
cat "${1:-/dev/stdin}" > "${2:-/dev/stdout}"

while read line; do
    echo "reading: ${line}"
done < /dev/stdin

### 标准错误输出
> result=$(ls -lh 2>&1 1>/dev/null)  //标准错误输出到变量
> ls -lh 2>> result.log  //标准错误追加到文件

## shell中的括号
### 单小括号 ()
1. 命令组, 括号中的命令将会新开一个子shell顺序执行, 括号中多个命令之间用分号隔开
2. 命令替换, 等同于`cmd`, 有些shell不支持, 如tcsh
3. 初始化数组, 如 array=(a b c d)
### 双小括号 (())
1. 整数扩展, ((exp)), 这种扩展计算是整数型的计算, 不支持浮点型
如果表达式的结果为0, 返回的状态码为1, 或者是 'false'; 若是逻辑判断, 表达式为真则为1, 假为0
只要括号中的运算符, 表达式符合C语言运算规则, 都可用在$((exp))中, 甚至是三目运算符, 作不同进位(如二进制, 八进制, 十六进制)运算时, 输出结果全都自动转化成了十进制, 如: echo $((16#5f)) 结果为95 (16进位转十进制)
2. 单纯用 (())也可以重定义变量值, 如 a=5; ((a++))
双括号中的变量可以不使用$符号前缀, 括号内支持多个表达式用分号分开
### 单中括号 []
1. bash的内部命令, [和test是等同的
Test和[]中可用的比较运算符只有==和!=, 两者都是用于字符串比较的, 不可用于整数比较, 整数比较只能使用-eq, -gt这种形式
2. 字符范围; 用作正则表达式的一部分, 描述一个匹配的字符范围; 作为test用途的中括号内不能使用正则
3. 在一个array 结构的上下文中, 中括号用来引用数组中每个元素的编号
### 双中括号 [[]]
1. [[是 bash 程序语言的关键字; 并不是一个命令, [[ ]] 结构比[ ]结构更加通用; 在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割, 但是会发生参数扩展和命令替换
2. 支持字符串的模式匹配, 使用=~操作符时甚至支持shell的正则表达式; 字符串比较时可以把右边的作为一个模式, 而不仅仅是一个字符串, 比如[[ hello == hell? ]], 结果为真; [[ ]] 中匹配字符串或通配符, 不需要引号
3. 使用[[ ... ]]条件判断结构, 而不是[ ... ], 能够防止脚本中的许多逻辑错误; 比如, &&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中的话, 会报错
4. bash把双中括号中的表达式看作一个单独的元素, 并返回一个退出状态码
### 大括号 {}
1. 大括号扩展, (通配, globbing)将对大括号中的文件名做扩展, 在大括号中, 不允许有空白, 除非这个空白被引用或转义; 第一种: 对大括号中的以逗号分割的文件列表进行拓展; 如 touch {a,b}.txt 结果为a.txt b.txt; 第二种: 对大括号中以点点（..）分割的顺序文件列表起拓展作用, 如: touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt
> ls {ex1,ex2}.sh
> ls {ex{1..3},ex4}.sh
> ls {ex[1-3],ex4}.sh
2. 代码块, 又被称为内部组, 这个结构事实上创建了一个匿名函数; 与小括号中的命令不同, 大括号内的命令不会新开一个子shell运行, 即脚本余下部分仍可使用括号内变量; 括号内的命令间用分号隔开, 最后一个也必须有分号
{}的第一个命令和左括号之间必须要有一个空格
### 几种特殊的替换结构
1. ${var:-string} 和 ${var:=string}  若变量var为空, 则用在命令行中用string来替换${var:-string}, 否则变量var不为空时, 则用变量var的值来替换${var:-string}; 对于${var:=string}的替换规则和${var:-string}是一样的, 所不同之处是${var:=string}若var为空时, 用string替换${var:=string}的同时, 把string赋给变量var
${var:=string}很常用的一种用法是, 判断某个变量是否赋值, 没有的话则给它赋上一个默认值 
2. ${var:+string}  替换规则和上面的相反, 即只有当var不是空的时候才替换成string, 若var为空时则不替换或者说是替换成变量 var的值, 即空值; (因为变量var此时为空, 所以这两种说法是等价的) 
3. ${var:?string}  替换规则为: 若变量var不为空, 则用变量var的值来替换${var:?string}; 若变量var为空, 则把string输出到标准错误中, 并从脚本中退出; 我们可利用此特性来检查是否设置了变量的值 
补充扩展: 在上面这五种替换结构中string不一定是常值的, 可用另外一个变量的值或是一种命令的输出
### 四种模式匹配替换结构
1. ${variable%pattern}  这种模式时, shell在variable中查找, 看它是否以给的模式pattern结尾, 如果是, 就从命令行把variable中的内容去掉右边最短的匹配模式
2. ${variable%%pattern}  这种模式时, shell在variable中查找, 看它是否以给的模式pattern结尾, 如果是, 就从命令行把variable中的内容去掉右边最长的匹配模式
3. ${variable#pattern}  这种模式时, shell在variable中查找, 看它是否以给的模式pattern开始, 如果是, 就从命令行把variable中的内容去掉左边最短的匹配模式
4. ${variable##pattern}  这种模式时, shell在variable中查找, 看它是否以给的模式pattern开始, 如果是, 就从命令行把variable中的内容去掉左边最长的匹配模式
这四种模式中都不会改变variable的值, 其中, 只有在pattern中使用了*匹配符号时, '%'和'%%', '#'和'##'才有区别; 结构中的pattern支持通配符, *表示零个或多个任意字符, ?表示零个或一个任意字符, [...]表示匹配中括号里面的字符, [!...]表示不匹配中括号里面的字符
<pre>
var=testcase
echo $var  //testcase
echo ${var%s*e}  //testca
echo $var //testcase
echo ${var%%s*e}  //te
echo ${var#?e}
echo ${var#?e}  //stcase
echo ${var##?e}  //stcase
echo ${var##*e}  //
echo ${var##*s}  //e
echo ${var##test}  //case
</pre>
